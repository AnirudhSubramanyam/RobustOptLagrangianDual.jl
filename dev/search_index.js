var documenterSearchIndex = {"docs":
[{"location":"examples/","page":"Examples","title":"Examples","text":"CurrentModule = RobustOptLagrangianDual","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Modules = [RobustOptLagrangianDual]\nOrder   = [:type, :function]\nPages   = [\"network.jl\", \"facility.jl\", \"rostering.jl\"]","category":"page"},{"location":"examples/#RobustOptLagrangianDual.NetworkDesign","page":"Examples","title":"RobustOptLagrangianDual.NetworkDesign","text":"NetworkDesign <: AbstractProblem\n\nDefault implementation of NetworkDesign problem.\n\n\n\n\n\n","category":"type"},{"location":"examples/#RobustOptLagrangianDual.FacilityLocation","page":"Examples","title":"RobustOptLagrangianDual.FacilityLocation","text":"FacilityLocation <: AbstractProblem\n\nDefault implementation of FacilityLocation problem.\n\n\n\n\n\n","category":"type"},{"location":"examples/#RobustOptLagrangianDual.Rostering","page":"Examples","title":"RobustOptLagrangianDual.Rostering","text":"Rostering <: AbstractProblem\n\nDefault implementation of Rostering problem.\n\n\n\n\n\n","category":"type"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"CurrentModule = RobustOptLagrangianDual","category":"page"},{"location":"solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Modules = [RobustOptLagrangianDual]\nOrder   = [:function]\nPages   = [\"RobustOptLagrangianDual.jl\"]","category":"page"},{"location":"solvers/#RobustOptLagrangianDual.set_num_threads-Tuple{Int64}","page":"Solvers","title":"RobustOptLagrangianDual.set_num_threads","text":"set_num_threads(threadlim::Int)\n\nSet the number of threads to use for parallel branch & bound.\n\n\n\n\n\n","category":"method"},{"location":"solvers/#RobustOptLagrangianDual.set_solver_CPLEX-Tuple{}","page":"Solvers","title":"RobustOptLagrangianDual.set_solver_CPLEX","text":"set_solver_CPLEX()\n\nSet the CPLEX solver. CPLEX must be separately installed and added via pkg> add CPLEX. The package defaults to SCIP if this function throws an error.\n\n\n\n\n\n","category":"method"},{"location":"solvers/#RobustOptLagrangianDual.set_solver_Gurobi-Tuple{}","page":"Solvers","title":"RobustOptLagrangianDual.set_solver_Gurobi","text":"set_solver_Gurobi()\n\nSet the Gurobi solver. Gurobi must be separately installed and added via pkg> add Gurobi. The package defaults to SCIP if this function throws an error.\n\n\n\n\n\n","category":"method"},{"location":"solvers/#RobustOptLagrangianDual.set_solver_Mosek-Tuple{}","page":"Solvers","title":"RobustOptLagrangianDual.set_solver_Mosek","text":"set_solver_Mosek()\n\nSet the Mosek solver. Mosek must be separately installed and added via pkg> add Mosek, MosekTools. The package defaults to SCIP if this function throws an error.\n\n\n\n\n\n","category":"method"},{"location":"solvers/#RobustOptLagrangianDual.set_solver_SCIP-Tuple{}","page":"Solvers","title":"RobustOptLagrangianDual.set_solver_SCIP","text":"set_solver_SCIP()\n\nSet the SCIP solver.\n\n\n\n\n\n","category":"method"},{"location":"#RobustOptLagrangianDual.jl","page":"Home","title":"RobustOptLagrangianDual.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RobustOptLagrangianDual.jl is a Julia implementation of a Lagrangian dual algorithm for solving two-stage robust optimization problems. The details of the algorithm and problem formulation can be found in the following papers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{subramanyam2022lagrangian,\n  title={A Lagrangian dual method for two-stage robust optimization with binary uncertainties},\n  author={Subramanyam, Anirudh},\n  journal={Optimization and Engineering},\n  volume={23},\n  number={4},\n  pages={1831--1871},\n  year={2022},\n  publisher={Springer}\n}\n@article{lefebvre2024correction,\n  title={Correction to: A Lagrangian dual method for two-stage robust optimization with binary uncertainties},\n  author={Lefebvre, Henri and Subramanyam, Anirudh},\n  journal={arXiv preprint arXiv:2411.04307},\n  year={2024}\n}","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be installed via:","category":"page"},{"location":"","page":"Home","title":"Home","text":"$ git clone https://github.com/AnirudhSubramanyam/RobustOptLagrangianDual.jl\n$ cd RobustOptLagrangianDual.jl\n$ julia --project","category":"page"},{"location":"","page":"Home","title":"Home","text":"Test the installation by running:","category":"page"},{"location":"","page":"Home","title":"Home","text":"$ julia --project test/test.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"By default, the package uses the SCIP solver. One can optionally use one of the following solvers as well, which must be installed separately:","category":"page"},{"location":"","page":"Home","title":"Home","text":"CPLEX\nGurobi\nMosek","category":"page"},{"location":"","page":"Home","title":"Home","text":"See also Solvers.","category":"page"},{"location":"#Documentation-and-Usage","page":"Home","title":"Documentation and Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"algorithms.md\",\n    \"solvers.md\",\n    \"internals.md\",\n    \"examples.md\",\n]\nDepth = 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example problem implementations can be found in src/network.jl, src/facility.jl and src/rostering.jl.","category":"page"},{"location":"#Funding","page":"Home","title":"Funding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This research was supported in part by the U.S. Department of Energy, Office of Science, Advanced Scientific Computing Research, under Contract DE-AC02-06CH11357, and in part by the U.S. National Science Foundation under grant DMS-2229408.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"CurrentModule = RobustOptLagrangianDual","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Modules = [RobustOptLagrangianDual]\nOrder   = [:type, :function]\nPages   = [\"problem.jl\"]","category":"page"},{"location":"internals/#RobustOptLagrangianDual.AbstractProblem","page":"Internals","title":"RobustOptLagrangianDual.AbstractProblem","text":"AbstractProblem\n\nAbstract supertype for the definition of specific problems.\n\n\n\n\n\n","category":"type"},{"location":"internals/#RobustOptLagrangianDual.MasterType","page":"Internals","title":"RobustOptLagrangianDual.MasterType","text":"MasterType\n\nEnum representing the master problem type. Possible values are CCG and Benders.\n\n\n\n\n\n","category":"type"},{"location":"internals/#RobustOptLagrangianDual.SubproblemType","page":"Internals","title":"RobustOptLagrangianDual.SubproblemType","text":"SubproblemType\n\nEnum representing the subproblem type. Possible values are LinearizedKKT, IndicatorKKT, LinearizedDual, IndicatorDual and LagrangianDual.\n\n\n\n\n\n","category":"type"},{"location":"internals/#RobustOptLagrangianDual.build_checking_sp","page":"Internals","title":"RobustOptLagrangianDual.build_checking_sp","text":"build_checking_sp(problem::AbstractProblem, MP::JuMP.Model)\n\nReturn the JuMP model of the optimality type subproblem, which also computes an optimal Lagrangian coefficient based on the optimal values of the solved master problem MP.\n\nMust be implemented if mixed_integer_recourse(problem) == false.\n\n\n\n\n\n","category":"function"},{"location":"internals/#RobustOptLagrangianDual.build_feasibility_sp","page":"Internals","title":"RobustOptLagrangianDual.build_feasibility_sp","text":"build_feasibility_sp(problem::AbstractProblem, MP::JuMP.Model, subproblem::SubproblemType)\n\nReturn the JuMP model of the feasibility type subproblem based on the optimal value of the master model MP.\n\nMust be implemented if mixed_integer_recourse(problem) == false && complete_recourse(problem) == false.\n\n\n\n\n\n","category":"function"},{"location":"internals/#RobustOptLagrangianDual.build_master_inner_level_check","page":"Internals","title":"RobustOptLagrangianDual.build_master_inner_level_check","text":"build_master_inner_level_check(problem::AbstractProblem, MP_outer::JuMP.Model, discrete_decision_list::Dict)\n\nReturn the JuMP model of the inner-level master problem, which also computes an optimal Lagrangian coefficient, based on the optimal values of the solved outer-level master problem MP_outer.\n\nMust be implemented if mixed_integer_recourse(problem) = true.\n\n\n\n\n\n","category":"function"},{"location":"internals/#RobustOptLagrangianDual.build_second_stage_problem","page":"Internals","title":"RobustOptLagrangianDual.build_second_stage_problem","text":"build_second_stage_problem(problem::AbstractProblem, MP_outer::JuMP.Model, MP_inner::JuMP.Model)\n\nReturn the JuMP model of the deterministic second-stage problem based on the optimal values of the outer-level MP_outer and inner-level MP_inner master models.\n\nMust be implemented if mixed_integer_recourse(problem) == true.\n\n\n\n\n\n","category":"function"},{"location":"internals/#RobustOptLagrangianDual.build_sp","page":"Internals","title":"RobustOptLagrangianDual.build_sp","text":"build_sp(problem::AbstractProblem, MP::JuMP.Model, subproblem::SubproblemType, λ::Float64 = 1.0)\n\nReturn the JuMP model of the optimality type subproblem based on the optimal value of the master model MP and the Lagrangian coefficient λ.\n\nMust be implemented if mixed_integer_recourse(problem) == false.\n\n\n\n\n\n","category":"function"},{"location":"internals/#RobustOptLagrangianDual.complete_recourse","page":"Internals","title":"RobustOptLagrangianDual.complete_recourse","text":"complete_recourse(problem::AbstractProblem)\n\nReturn true if problem satisfies complete recourse and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"internals/#RobustOptLagrangianDual.compute_lagrangian_coefficient","page":"Internals","title":"RobustOptLagrangianDual.compute_lagrangian_coefficient","text":"function compute_lagrangian_parameter(problem::AbstractProblem, MP::JuMP.Model)\n\nReturn an optimal Lagrangian coefficient based on the optimal value of the (outer-level) master model MP.\n\nMust be implemented if indicator_uncertainty(problem) == false.\n\n\n\n\n\n","category":"function"},{"location":"internals/#RobustOptLagrangianDual.indicator_uncertainty","page":"Internals","title":"RobustOptLagrangianDual.indicator_uncertainty","text":"indicator_uncertainty(problem::AbstractProblem)\n\nReturn true if problem has indicator uncertainties only and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"internals/#RobustOptLagrangianDual.init_lagrangian_coefficient","page":"Internals","title":"RobustOptLagrangianDual.init_lagrangian_coefficient","text":"function init_lagrangian_coefficient(problem::AbstractProblem, P::JuMP.Model)\n\nReturn an optimal Lagrangian coefficient computing using the solved JuMP model P built using either build_checking_sp if mixed_integer_recourse(problem) == false or build_master_inner_level_check if mixed_integer_recourse(problem) == true.\n\n\n\n\n\n","category":"function"},{"location":"internals/#RobustOptLagrangianDual.init_master","page":"Internals","title":"RobustOptLagrangianDual.init_master","text":"init_master(problem::AbstractProblem)\n\nInitialize the (outer-level) master model with variables and constraints.\n\n\n\n\n\n","category":"function"},{"location":"internals/#RobustOptLagrangianDual.init_master_inner_level","page":"Internals","title":"RobustOptLagrangianDual.init_master_inner_level","text":"init_master_inner_level(problem::AbstractProblem)\ninit_master_inner_level(problem::AbstractProblem, MP_inner::JuMP.Model)\ninit_master_inner_level(problem::AbstractProblem, MP_outer::JuMP.Model, discrete_decision_list::Dict, master_inner::SubproblemType, λ = nothing)\n\nInitialize the inner-level master model with variables and constraints.\n\nMust be implemented if mixed_integer_recourse(problem) == true.\n\nIn the second version, the variable values must be fixed to optimal values of the solved inner-level master model MP_inner.\n\nIn the third version, the model must be built using the first-stage decisions in the solved outer-level master model MP_outer, the discrete second-stage decisions stored in the discrete_decision_list dictionary, and the master_inner type of the inner-level master model. The Lagrangian coefficient λ must be Float64 if master_inner == LagrangianDual.\n\n\n\n\n\n","category":"function"},{"location":"internals/#RobustOptLagrangianDual.mixed_integer_recourse","page":"Internals","title":"RobustOptLagrangianDual.mixed_integer_recourse","text":"mixed_integer_recourse(problem::AbstractProblem)\n\nReturn true if problem has mixed-integer recourse variables and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"internals/#RobustOptLagrangianDual.objective_scale","page":"Internals","title":"RobustOptLagrangianDual.objective_scale","text":"objective_scale(problem::AbstractProblem)\n\nReturn the objective scaling factor of problem.\n\n\n\n\n\n","category":"function"},{"location":"internals/#RobustOptLagrangianDual.record_discrete_second_stage_decision","page":"Internals","title":"RobustOptLagrangianDual.record_discrete_second_stage_decision","text":"record_discrete_second_stage_decision(problem::AbstractProblem, SP::JuMP.Model, discrete_decision_list::Dict)\n\nRecord the optimal discrete second-stage decisions from the solved subproblem model SP in the discrete_decision_list dictionary.\n\nReturn true if the decision already existed in discrete_decision_list and false otherwise.\n\nMust be implemented if mixed_integer_recourse(problem) == true.\n\n\n\n\n\n","category":"function"},{"location":"internals/#RobustOptLagrangianDual.record_scenario","page":"Internals","title":"RobustOptLagrangianDual.record_scenario","text":"record_scenario(problem::AbstractProblem, SP::JuMP.Model, scenario_list::Dict)\n\nThis is only for debugging purposes. Record the optimal value of the subproblem model SP in the scenario_list dictionary.\n\nReturn true if the scenario already existed in scenario_list and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"internals/#RobustOptLagrangianDual.solve_deterministic_problem","page":"Internals","title":"RobustOptLagrangianDual.solve_deterministic_problem","text":"solve_deterministic_problem(problem::AbstractProblem)\n\nSolve deterministic problem for nominal parameter values.\n\nReturn the optimal objective value.\n\n\n\n\n\n","category":"function"},{"location":"internals/#RobustOptLagrangianDual.solve_second_stage_problem_lagrangian","page":"Internals","title":"RobustOptLagrangianDual.solve_second_stage_problem_lagrangian","text":"solve_second_stage_problem_lagrangian(problem::AbstractProblem, MP::JuMP.Model, SP::JuMP.Model, λ::Float64)\n\nSolve the second-stage Lagrangian problem with coefficient λ based on the optimal values of the master model MP and subproblem SP.\n\nReturn the optimal value of the Lagrangian penalty term.\n\n\n\n\n\n","category":"function"},{"location":"internals/#RobustOptLagrangianDual.update_master_continous","page":"Internals","title":"RobustOptLagrangianDual.update_master_continous","text":"update_master_continuous(problem::AbstractProblem, MP::JuMP.Model, SP::JuMP.Model, master::MasterType, subproblem::SubproblemType)\n\nUpdate the master model MP based on the optimal value of the continuous subproblem model SP, the master type and subproblem type.\n\nMust be implemented if mixed_integer_recourse(problem) == false.\n\n\n\n\n\n","category":"function"},{"location":"internals/#RobustOptLagrangianDual.update_master_inner_level","page":"Internals","title":"RobustOptLagrangianDual.update_master_inner_level","text":"update_master_inner_level(problem::AbstractProblem, MP_inner::JuMP.Model, MP_outer::JuMP.Model, SP::JuMP.Model, master_inner::SubproblemType, λ = nothing)\n\nUpdate the inner-level master model MP_inner based on the optimal values of the outer-level master model MP_outer, the subproblem model SP, and the master_inner type of the inner-level master model.\n\nThe Lagrangian coefficient λ must be Float64 if master_inner == LagrangianDual.\n\nMust be implemented if mixed_integer_recourse(problem) = true.\n\n\n\n\n\n","category":"function"},{"location":"internals/#RobustOptLagrangianDual.update_master_mixed_integer","page":"Internals","title":"RobustOptLagrangianDual.update_master_mixed_integer","text":"update_master_mixed_integer(problem::AbstractProblem, MP_outer::JuMP.Model, MP_inner::JuMP.Model, master::MasterType)\n\nUpdate the outer-level master model MP_outer based on the optimal value of the mixed-integer inner-level master model MP_inner and the master type of the inner-level master model.\n\nMust be implemented if mixed_integer_recourse(problem) = true.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"CurrentModule = RobustOptLagrangianDual","category":"page"},{"location":"algorithms/#Algorithms","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Modules = [RobustOptLagrangianDual]\nOrder   = [:function]\nPages   = [\"algorithms.jl\"]","category":"page"},{"location":"algorithms/#RobustOptLagrangianDual.run_benders","page":"Algorithms","title":"RobustOptLagrangianDual.run_benders","text":"run_benders(problem::AbstractProblem, subproblemtype::SubproblemType, time_limit::Float64, opt_tol::Float64 = 1e-4, feas_tol::Float64 = 1e-5)\n\nSolve problem using the benders decomposition algorithm using the subproblemtype subproblem with specified time_limit (in seconds) and optimality and feasibility tolerances of opt_tol and feas_tol, respectively.\n\nReturns (num_iter, lb, ub, total_time, nothing)\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#RobustOptLagrangianDual.run_ccg","page":"Algorithms","title":"RobustOptLagrangianDual.run_ccg","text":"run_ccg(problem::AbstractProblem, subproblemtype::SubproblemType, time_limit::Float64, opt_tol::Float64 = 1e-4, feas_tol::Float64 = 1e-5)\n\nSolve problem using the column-and-constraint generation algorithm using the subproblemtype subproblem with specified time_limit (in seconds) and optimality and feasibility tolerances of opt_tol and feas_tol, respectively.\n\nReturns (num_iter, lb, ub, total_time, iter_inner)\n\n\n\n\n\n","category":"function"}]
}
